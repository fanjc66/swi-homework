# 排序算法

1.  Bubble Sort the list: 33, 56, 17, 8, 95, 22。
伪代码
```
list = {33, 56, 17, 8, 95, 22}
FOR i form list_length-1 to 0 DO
    FOR j form 0 to i-1 DO
        IF list[j] > list[j+1] THEN
            swap(list[j], list[j+1])
        END IF
        IF list is in order THEN
            END FOR
        END IF
    END FOR
```

c 语言实现



```
#include <stdio.h>
void b_sort(int *num, int len);
int main()
{
	int len = 6;
	/* list = {33, 56, 17, 8, 95, 22} */
	int num[6] = {33, 56, 17, 8, 95, 22};	
	
			
		b_sort(num, len);
	
}
void b_sort(int *num, int len)
{
	int i, j;
	int flag = 0;
	for (i = len-1; i > 0; --i) //i “为有序数列 ”起始角标 
	{
		int flag = 0, k;
		for (j = 0; j < i; ++j)
		{
			if (num[j] > num[j+1])
			{
				int tmp = num[j];	num[j] = num[j+1];	num[j+1] = tmp;
				flag = 1;
			}
			for (k = 0; k < len; ++k)
				printf("%d ", num[k]);
			printf("\n");
		}
		if (!flag)	break;		//遍历数组没有发生交换，排序完成 
	}
}
```
![FQE0KA.png](https://s1.ax1x.com/2018/12/04/FQE0KA.png)

2. Give a sorted array as list={60,65,75,80,90,95}. Design an algorithm to insert the value of x into the sorted array. Then test the algorithm with value 50,67,99. 思考：为什么选择插入点在list头上、中间、尾巴上的三个数作为算 法测试的数据，你能解释吗？

伪代码
```
list={60,65,75,80,90,95}
READ inserNumber
FOR i from i to list_length-1 DO
	IF READ < list[i]
		index = i
		END FOR
	END IF
END FOR

IF not found bigger number in list THEN
	list[list_length] = number
	OUTPUT
END IF

IF has bigger number if list THEN
	FOR i from list_length to i+1 DO
		list[i] = list[i-1]
	END FOR
END IF

OUTPUT
```

c语言实现

```
#include <stdio.h>

int main()
{
	int number;
	int i, j, index, flag = 0;
	int list[10] = {60,65,75,80,90,95};
	int list_length = 6;
	
	scanf("%d", &number);
	for (i = 0; i < list_length; ++i)
	{
		if (number < list[i])			//找到有序数列中的第一个大于插入数的数 
		{
			flag = 1;					//判断能否在数组中找到比插入数大的数 
			index = i;
			break;
		}
	}
	if (!flag)  list[list_length] = number; 
	else{
		for (i = list_length; i > index; --i)
		{
			list[i] = list[i-1];
		}
		list [index] = number;
	}
	
	/* OUTPUT */
	for (i = 0; i < list_length; ++i)
		printf("%d ", list[i]);
	printf("%d ", list[i]);
}
```

选择插入点在list头上、中间、尾巴上的三个数作为算法测试的数据, 使程序运行不同的分支结构，数据监测更具有普遍性，检测更全面。


[![FQ3DqU.png](https://s1.ax1x.com/2018/12/04/FQ3DqU.png)](https://imgchr.com/i/FQ3DqU)


[![FQ3sZF.png](https://s1.ax1x.com/2018/12/04/FQ3sZF.png)](https://imgchr.com/i/FQ3sZF)


[![FQ3BrT.png](https://s1.ax1x.com/2018/12/04/FQ3BrT.png)](https://imgchr.com/i/FQ3BrT)

3. What is the state of the stack after the following sequence of Push and Pop operations? Push “anne”; Push “get”; Push “your” ; Pop; Push “my” Push “gun” 

push "anne" > 先令堆栈指令sp减2， 将"anne" 存入
>（1）、进栈指令push
push reg/mem/seg；sp<-sp-2,ss<-reg/mem/seg
进栈指令先使堆栈指令sp减2，然后把一个字操作数存入堆栈顶部。堆栈操作的对象只能是字操作数，进栈时底字节存放于低地址，高字节存放于高地址，sp相应向低地址移动两个字节单元。


solution: "anne" "get" "my" "gun"  